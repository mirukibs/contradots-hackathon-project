@startuml ApplicationLayer
skinparam packageStyle rectangle
skinparam classAttributeIconSize 0
title Application Layer - CQRS Architecture with Authentication (Orchestrates Domain Logic)

' =======================
' AUTHENTICATION & AUTHORIZATION
' =======================
package "Authentication & Authorization" <<Security>> {
    class AuthenticationContext {
        +currentUserId : PersonId
        +email : string
        +roles : List<Role>
        +isAuthenticated : boolean
        +canActAs(personId : PersonId) : boolean
        +hasRole(role : Role) : boolean
        +canAccessResource(resourceId : string, operation : string) : boolean
    }
    
    class AuthorizationService {
        +validateUserCanActAs(auth : AuthContext, targetPersonId : PersonId) : void
        +validateRolePermission(auth : AuthContext, operation : string) : void
        +enforceResourceAccess(auth : AuthContext, resourceId : string) : void
        +enforceActivityOwnership(auth : AuthContext, activityId : ActivityId) : void
        -personRepo : PersonRepository
    }
    
    class AuthenticationException {
        +message : string
        +email : string
        +attemptedAt : DateTime
        +AuthenticationException(message : string, email : string)
    }
    
    class AuthorizationException {
        +message : string
        +userId : PersonId
        +operation : string
        +resourceId : string
        +attemptedAt : DateTime
        +AuthorizationException(message : string, userId : PersonId, operation : string)
    }
}

' =======================
' APPLICATION SERVICES
' =======================
package "Application Services" <<Cloud>> {
    
    class PersonApplicationService {
        +registerPerson(command : RegisterPersonCommand) : PersonId
        +authenticateUser(command : AuthenticateUserCommand) : AuthenticationResultDto
        +getPersonProfile(personId : PersonId, auth : AuthContext) : PersonProfileDto
        +getCurrentUserProfile(auth : AuthContext) : PersonProfileDto
        +getLeaderboard(auth : AuthContext) : LeaderboardDto[]
        -personRepo : PersonRepository
        -leaderboardQueryRepo : LeaderboardQueryRepository
        -authorizationService : AuthorizationService
    }
    
    class ActivityApplicationService {
        +createActivity(command : CreateActivityCommand, auth : AuthContext) : ActivityId
        +getActiveActivities(auth : AuthContext) : ActivityDto[]
        +getActivityDetails(activityId : ActivityId, auth : AuthContext) : ActivityDetailsDto
        +deactivateActivity(command : DeactivateActivityCommand, auth : AuthContext) : void
        -activityRepo : ActivityRepository
        -activityQueryRepo : ActivityQueryRepository
        -personRepo : PersonRepository
        -authorizationService : AuthorizationService
    }
    
    class ActionApplicationService {
        +submitAction(command : SubmitActionCommand, auth : AuthContext) : ActionId
        +getPendingValidations(auth : AuthContext) : ActionDto[]
        +getPersonActions(personId : PersonId, auth : AuthContext) : ActionDto[]
        +getMyActions(auth : AuthContext) : ActionDto[]
        +simulateProofValidation(command : ValidateProofCommand, auth : AuthContext) : void
        -actionRepo : ActionRepository
        -actionQueryRepo : ActionQueryRepository
        -activityRepo : ActivityRepository
        -eventPublisher : EventPublisher
        -authorizationService : AuthorizationService
    }
}

' =======================
' COMMAND OBJECTS (Input)
' =======================
package "Commands" <<Folder>> {
    class RegisterPersonCommand {
        +name : string
        +email : string
        +role : string
        +validate() : void
    }
    
    class AuthenticateUserCommand {
        +email : string
        +password : string
        +validate() : void
    }
    
    class CreateActivityCommand {
        +name : string
        +description : string
        +points : int
        +leadId : PersonId
        +validate() : void
        +validateAuthorization(auth : AuthContext) : void
    }
    
    class SubmitActionCommand {
        +personId : PersonId
        +activityId : ActivityId
        +description : string
        +proofHash : string
        +validate() : void
        +validateAuthorization(auth : AuthContext) : void
    }
    
    class DeactivateActivityCommand {
        +activityId : ActivityId
        +leadId : PersonId
        +validate() : void
        +validateAuthorization(auth : AuthContext) : void
    }
    
    class ValidateProofCommand {
        +actionId : ActionId
        +isValid : boolean
        +validate() : void
        +validateAuthorization(auth : AuthContext) : void
    }
}

' =======================
' DTO OBJECTS (Output)  
' =======================
package "DTOs" <<Folder>> {
    class PersonProfileDto {
        +personId : string
        +name : string
        +email : string
        +role : string
        +reputationScore : int
    }
    
    class AuthenticationResultDto {
        +accessToken : string
        +refreshToken : string
        +personId : string
        +email : string
        +roles : List<string>
        +expiresAt : DateTime
    }
    
    class LeaderboardDto {
        +personId : string
        +name : string
        +reputationScore : int
        +rank : int
    }
    
    class ActivityDto {
        +activityId : string
        +name : string
        +description : string
        +points : int
        +leadName : string
        +isActive : boolean
    }
    
    class ActivityDetailsDto {
        +activityId : string
        +name : string
        +description : string
        +points : int
        +leadName : string
        +isActive : boolean
        +participantCount : int
        +totalActionsSubmitted : int
    }
    
    class ActionDto {
        +actionId : string
        +personName : string
        +activityName : string
        +description : string
        +status : string
        +submittedAt : string
    }
}

' =======================
' CQRS REPOSITORIES
' =======================
package "Command Side (Write)" <<Database>> {
    interface PersonRepository {
        +findById(personId : PersonId) : Person
        +findByEmail(email : string) : Person
        +save(person : Person) : void
        +findAll() : Person[]
    }
    
    interface ActivityRepository {
        +findById(activityId : ActivityId) : Activity
        +save(activity : Activity) : void
        +findActive() : Activity[]
        +findByLeadId(leadId : PersonId) : Activity[]
    }
    
    interface ActionRepository {
        +findById(actionId : ActionId) : Action
        +save(action : Action) : void
        +findPendingValidation() : Action[]
        +findByPersonId(personId : PersonId) : Action[]
        +findByActivityId(activityId : ActivityId) : Action[]
    }
}

package "Query Side (Read)" <<Storage>> {
    interface LeaderboardQueryRepository {
        +getLeaderboard() : LeaderboardDto[]
        +getPersonRank(personId : PersonId) : int
    }
    
    interface ActivityQueryRepository {
        +getActiveActivities() : ActivityDto[]
        +getActivityDetails(activityId : ActivityId) : ActivityDetailsDto
    }
    
    interface ActionQueryRepository {
        +getPendingValidations() : ActionDto[]
        +getPersonActions(personId : PersonId) : ActionDto[]
        +getActivityActions(activityId : ActivityId) : ActionDto[]
    }
}

' =======================
' EVENT INFRASTRUCTURE
' =======================
package "Event Infrastructure" <<Component>> {
    interface EventStore {
        +append(aggregateId : UUID, events : DomainEvent[]) : void
        +getEvents(aggregateId : UUID) : DomainEvent[]
        +getAllEvents() : DomainEvent[]
    }
    
    interface EventPublisher {
        +publish(event : DomainEvent) : void
        +publishAll(events : DomainEvent[]) : void
        -eventStore : EventStore
        -handlers : EventHandler[]
    }
    
    interface EventHandler<T extends DomainEvent> {
        +handle(event : T) : void
        +canHandle(event : DomainEvent) : boolean
    }
}

' =======================
' DOMAIN EVENTS (Same as Domain Layer)
' =======================
package "Domain Events" <<Node>> {
    abstract class DomainEvent {
        +eventId : UUID
        +occurredAt : DateTime
        +aggregateId : UUID
        +aggregateType : string
    }
    
    class ActionSubmittedEvent extends DomainEvent {
        +actionId : ActionId
        +personId : PersonId
        +activityId : ActivityId
        +description : string
        +proofHash : string
    }
    
    class ProofValidatedEvent extends DomainEvent {
        +actionId : ActionId
        +personId : PersonId
        +activityId : ActivityId
        +isValid : boolean
    }
}

' =======================
' EVENT HANDLERS (Bridge Domain & Application)
' =======================
package "Event Handlers" <<Component>> {
    class ReputationEventHandler implements EventHandler {
        +handle(event : ActionSubmittedEvent) : void
        +handle(event : ProofValidatedEvent) : void
        +canHandle(event : DomainEvent) : boolean
        -personRepo : PersonRepository
        -activityRepo : ActivityRepository
        -reputationService : ReputationService
    }
    
    class LeaderboardProjectionHandler implements EventHandler {
        +handle(event : ActionSubmittedEvent) : void
        +handle(event : ProofValidatedEvent) : void
        +canHandle(event : DomainEvent) : boolean
        -leaderboardRepo : LeaderboardQueryRepository
    }
    
    class ActivityProjectionHandler implements EventHandler {
        +handle(event : ActionSubmittedEvent) : void
        +canHandle(event : DomainEvent) : boolean
        -activityQueryRepo : ActivityQueryRepository
    }
}

' =======================
' DOMAIN SERVICES (From Domain Layer)
' =======================
package "Domain Services" <<Component>> {
    class ReputationService {
        +calculatePoints(activityId : ActivityId) : int
        +updatePersonReputation(personId : PersonId, points : int) : void
        +calculatePersonReputation(person : Person, verifiedActions : List<Action>) : int
    }
}

' =======================
' APPLICATION SERVICE USAGE
' =======================

' Authentication Context Usage
PersonApplicationService ..> AuthenticationContext : "requires for secure operations"
ActivityApplicationService ..> AuthenticationContext : "requires for secure operations"
ActionApplicationService ..> AuthenticationContext : "requires for secure operations"

' Authorization Service Usage
PersonApplicationService ..> AuthorizationService : "validates permissions"
ActivityApplicationService ..> AuthorizationService : "validates permissions"
ActionApplicationService ..> AuthorizationService : "validates permissions"

' Commands → Application Services (with auth validation)
PersonApplicationService ..> RegisterPersonCommand : "validates & processes"
PersonApplicationService ..> AuthenticateUserCommand : "validates & processes"
ActivityApplicationService ..> CreateActivityCommand : "validates & processes"  
ActivityApplicationService ..> DeactivateActivityCommand : "validates & processes"
ActionApplicationService ..> SubmitActionCommand : "validates & processes"
ActionApplicationService ..> ValidateProofCommand : "validates & processes"

' Command Authorization Validation
CreateActivityCommand ..> AuthenticationContext : "validates authorization"
SubmitActionCommand ..> AuthenticationContext : "validates authorization"
DeactivateActivityCommand ..> AuthenticationContext : "validates authorization"
ValidateProofCommand ..> AuthenticationContext : "validates authorization"

' Application Services → DTOs  
PersonApplicationService ..> PersonProfileDto : "returns"
PersonApplicationService ..> AuthenticationResultDto : "returns"
PersonApplicationService ..> LeaderboardDto : "returns"
ActivityApplicationService ..> ActivityDto : "returns"
ActivityApplicationService ..> ActivityDetailsDto : "returns"
ActionApplicationService ..> ActionDto : "returns"

' CQRS Repository Usage
PersonApplicationService ..> PersonRepository : "write operations"
PersonApplicationService ..> LeaderboardQueryRepository : "read operations"
ActivityApplicationService ..> ActivityRepository : "write operations"
ActivityApplicationService ..> ActivityQueryRepository : "read operations"
ActionApplicationService ..> ActionRepository : "write operations"
ActionApplicationService ..> ActionQueryRepository : "read operations"

' Event Publishing
ActionApplicationService ..> EventPublisher : "publishes events"

' =======================
' EVENT-DRIVEN FLOW
' =======================

' Domain Events Published
ActionApplicationService ..> ActionSubmittedEvent : "publishes on action submit"
ActionApplicationService ..> ProofValidatedEvent : "publishes on proof validation"

' Event Handling  
ActionSubmittedEvent ..> ReputationEventHandler : "triggers domain update"
ActionSubmittedEvent ..> LeaderboardProjectionHandler : "triggers read projection"
ActionSubmittedEvent ..> ActivityProjectionHandler : "triggers read projection"

ProofValidatedEvent ..> ReputationEventHandler : "triggers domain update"
ProofValidatedEvent ..> LeaderboardProjectionHandler : "triggers read projection"

' Event Handlers → Repositories
ReputationEventHandler ..> PersonRepository : "updates domain state"
ReputationEventHandler ..> ActivityRepository : "reads activity data"
ReputationEventHandler ..> ReputationService : "calculates points"

LeaderboardProjectionHandler ..> LeaderboardQueryRepository : "updates projections"
ActivityProjectionHandler ..> ActivityQueryRepository : "updates projections"

' Infrastructure
EventPublisher ..> EventStore : "persists events"
EventPublisher ..> EventHandler : "notifies handlers"

' Command Repositories → Event Publishing
PersonRepository ..> EventPublisher : "publishes on save"
ActivityRepository ..> EventPublisher : "publishes on save"
ActionRepository ..> EventPublisher : "publishes on save"

' =======================
' DEVELOPER NOTES
' =======================
note top of PersonApplicationService : "**Handles:**\n• User registration (public)\n• User authentication\n• Profile queries (auth required)\n• Leaderboard generation"

note top of ActivityApplicationService : "**Handles:**\n• Activity creation (Lead only)\n• Activity queries (auth required)\n• Activity management (creator only)"

note top of ActionApplicationService : "**Handles:**\n• Action submission (auth required)\n• Proof validation (Lead only)\n• Event publishing"

note top of AuthenticationContext : "**Security Context:**\n• Current user identity\n• Role-based permissions\n• Resource access validation"

note top of AuthorizationService : "**Authorization Logic:**\n• User identity validation\n• Role permission checks\n• Resource ownership enforcement"

note bottom of ReputationEventHandler : "**Domain Logic:**\nUpdates Person.reputationScore\nbased on action events"

note bottom of LeaderboardProjectionHandler : "**Read Optimization:**\nMaintains leaderboard views\nfor fast query performance"

note bottom of ActivityProjectionHandler : "**Read Optimization:**\nMaintains activity statistics\nfor dashboard displays"

note as CQRSFlow
**Secure CQRS Flow Example:**

1. **Authentication:** User login → AuthenticationContext created
2. **Command:** SubmitActionCommand + AuthContext → ActionApplicationService
3. **Authorization:** Command validates user can act as personId
4. **Domain:** Creates Action aggregate → ActionSubmittedEvent  
5. **Write:** Action saved to command store
6. **Event:** ActionSubmittedEvent published
7. **Handlers:** Update domain (Person) + projections (Leaderboard)
8. **Query:** Fast reads from optimized projections (auth-filtered)

This ensures **authentication** at entry points,
**authorization** for all operations, and
**secure access** to all resources.
end note

@enduml